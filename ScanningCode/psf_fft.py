import numpy as np
import scipy
import sys
sys.path.insert(0, './Misc')
from nearest_small_prime import nearest_small_prime

def psf_fft(vol_sz, psf, *args):

# scan_volume(neur_vol, psf, *args)
# return scan_img 
#
# Scan a 3D volume with a given point-spread function. This function takes
# in a neural volume (as generated by "simulate_neural_vol_v*.m"), a
# point-spread function, and a number of other optional scanning parameters
# in order to simulate the images resulting from a two-photon scan of the
# volume with the given PSF. Inputs to this function are:
#   - neur_vol - 3D volume where each voxel contains the fluorescence
#   - psf      - 3D array containing the intensity of the point-spread
#                function
#   - z_sub    - OPTIONAL speed-up parameter that scans multiple slices
#                simultaneously, reducing the number of convolutions needed
#                by a factor of 'z_sub'
#
# The output is
#   - scan_img - The scanned image - i.e. the return fluorescence from the
#                point-spread function with no noise (photon or electronic)
#
# 2016 - Adam Charles

###########################################################################
## Parse Inputs
    nargin = len(args)
    if nargin > 0:
        z_sub = args[0]
    else:
        z_sub = 1
    

    ###########################################################################
    ## Calculate and sum convolutions

    if z_sub > 1:                                                               # For time considerations, can pre-sum every few slices
        N_slce    = np.ceil(np.size(psf,2)/z_sub)                                     # Figure out how many slices after pre-summing
        psf2      = psf[:,:,:z_sub:z_sub*N_slce]                             # Initialize the new point-spread function
        for kk in np.linspace(2,z_sub):
            slcs                = np.linspace(kk,z_sub,min(z_sub*N_slce, np.size(psf,2)))       # Slices to add
            Nz                  = np.size(slcs)                                 # Figure out how many slices in the kk^th sub-sampling (in case 
            psf2[:,:,:Nz]      = psf2[:,:,:Nz] + psf[:,:,slcs]              # Iteratively add in the PSF slices
        sz = vol_sz + len(psf2) - 1                                          # Get the sizes of the post-convolution array
        sz = nearest_small_prime(sz,7)                                        # Make sure the largest factor is no larger than 7 (for fast FFTs)
        freq_psf = scipy.fft(scipy.fft(psf2, sz[0], 1), sz[1], 2)                         # Get fft of psf
    else:
        try:
            sz = vol_sz + len(psf) - 1                                       # Get the sizes of the post-convolution array
        except:
            sz = vol_sz + [len(psf), 1] - 1
        sz = nearest_small_prime(sz,7)                                      # Make sure the largest factor is no larger than 7 (for fast FFTs)
        freq_psf = scipy.fft(scipy.fft(psf, sz[0], 1), sz[1], 2)                          # Get fft of psf

    return freq_psf

###########################################################################
###########################################################################
